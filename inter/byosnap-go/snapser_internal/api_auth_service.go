/*
my-dev-cluster

Your custom SDK

API version: my-dev-cluster: v1 SDK
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package snapserInternal

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AuthServiceAPIService AuthServiceAPI service
type AuthServiceAPIService service

type ApiAuthInternalAnonLoginRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthAnonLoginRequest
}

func (r ApiAuthInternalAnonLoginRequest) Body(body AuthAnonLoginRequest) ApiAuthInternalAnonLoginRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalAnonLoginRequest) Execute() (*AuthAnonLoginResponse, *http.Response, error) {
	return r.ApiService.AuthInternalAnonLoginExecute(r)
}

/*
AuthInternalAnonLogin Anonymous Login

Logs in the user with an arbitrary identifier specified and returns a session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalAnonLoginRequest
*/
func (a *AuthServiceAPIService) AuthInternalAnonLogin(ctx context.Context) ApiAuthInternalAnonLoginRequest {
	return ApiAuthInternalAnonLoginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthAnonLoginResponse
func (a *AuthServiceAPIService) AuthInternalAnonLoginExecute(r ApiAuthInternalAnonLoginRequest) (*AuthAnonLoginResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthAnonLoginResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalAnonLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/login/anon"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalAppVerifyRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	type_ string
	sessionToken *string
	clientSecret *string
}

// Session token of the user
func (r ApiAuthInternalAppVerifyRequest) SessionToken(sessionToken string) ApiAuthInternalAppVerifyRequest {
	r.sessionToken = &sessionToken
	return r
}

// Shared secret used to verify the request
func (r ApiAuthInternalAppVerifyRequest) ClientSecret(clientSecret string) ApiAuthInternalAppVerifyRequest {
	r.clientSecret = &clientSecret
	return r
}

func (r ApiAuthInternalAppVerifyRequest) Execute() (*ApiHttpBody, *http.Response, error) {
	return r.ApiService.AuthInternalAppVerifyExecute(r)
}

/*
AuthInternalAppVerify Token

Verifies the session token and returns appropriate response based on the type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Type of app trying to verify the session token. Only acceptable value is 'photon'
 @return ApiAuthInternalAppVerifyRequest
*/
func (a *AuthServiceAPIService) AuthInternalAppVerify(ctx context.Context, type_ string) ApiAuthInternalAppVerifyRequest {
	return ApiAuthInternalAppVerifyRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
//  @return ApiHttpBody
func (a *AuthServiceAPIService) AuthInternalAppVerifyExecute(r ApiAuthInternalAppVerifyRequest) (*ApiHttpBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiHttpBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalAppVerify")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/app-verify/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sessionToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "session_token", r.sessionToken, "")
	}
	if r.clientSecret != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "client_secret", r.clientSecret, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalAppleLoginRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthAppleLoginRequest
}

func (r ApiAuthInternalAppleLoginRequest) Body(body AuthAppleLoginRequest) ApiAuthInternalAppleLoginRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalAppleLoginRequest) Execute() (*AuthAppleLoginResponse, *http.Response, error) {
	return r.ApiService.AuthInternalAppleLoginExecute(r)
}

/*
AuthInternalAppleLogin Apple Login

Logs in the user based on the apple credential token specified and returns a session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalAppleLoginRequest
*/
func (a *AuthServiceAPIService) AuthInternalAppleLogin(ctx context.Context) ApiAuthInternalAppleLoginRequest {
	return ApiAuthInternalAppleLoginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthAppleLoginResponse
func (a *AuthServiceAPIService) AuthInternalAppleLoginExecute(r ApiAuthInternalAppleLoginRequest) (*AuthAppleLoginResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthAppleLoginResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalAppleLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/login/apple"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalAssociateLoginsRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthAssociateLoginsRequest
}

func (r ApiAuthInternalAssociateLoginsRequest) Body(body AuthAssociateLoginsRequest) ApiAuthInternalAssociateLoginsRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalAssociateLoginsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AuthInternalAssociateLoginsExecute(r)
}

/*
AuthInternalAssociateLogins Associate Multiple Logins

Associates two logins based on their session tokens

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalAssociateLoginsRequest
*/
func (a *AuthServiceAPIService) AuthInternalAssociateLogins(ctx context.Context) ApiAuthInternalAssociateLoginsRequest {
	return ApiAuthInternalAssociateLoginsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AuthServiceAPIService) AuthInternalAssociateLoginsExecute(r ApiAuthInternalAssociateLoginsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalAssociateLogins")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/associate-logins"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalDisassociateLoginRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	userId string
	gateway *string
	body *DisassociateLoginRequest
}

// Gateway
func (r ApiAuthInternalDisassociateLoginRequest) Gateway(gateway string) ApiAuthInternalDisassociateLoginRequest {
	r.gateway = &gateway
	return r
}

func (r ApiAuthInternalDisassociateLoginRequest) Body(body DisassociateLoginRequest) ApiAuthInternalDisassociateLoginRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalDisassociateLoginRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AuthInternalDisassociateLoginExecute(r)
}

/*
AuthInternalDisassociateLogin Disassociate

Disassociates the specified login from a user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId UserID of the user to be unbanned
 @return ApiAuthInternalDisassociateLoginRequest
*/
func (a *AuthServiceAPIService) AuthInternalDisassociateLogin(ctx context.Context, userId string) ApiAuthInternalDisassociateLoginRequest {
	return ApiAuthInternalDisassociateLoginRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AuthServiceAPIService) AuthInternalDisassociateLoginExecute(r ApiAuthInternalDisassociateLoginRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalDisassociateLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/users/{user_id}/disassociation"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gateway == nil {
		return localVarReturnValue, nil, reportError("gateway is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Gateway", r.gateway, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalDiscordLoginRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthDiscordLoginRequest
}

func (r ApiAuthInternalDiscordLoginRequest) Body(body AuthDiscordLoginRequest) ApiAuthInternalDiscordLoginRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalDiscordLoginRequest) Execute() (*AuthDiscordLoginResponse, *http.Response, error) {
	return r.ApiService.AuthInternalDiscordLoginExecute(r)
}

/*
AuthInternalDiscordLogin Discord Login

Logs in the user based on the discord token specified and returns a session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalDiscordLoginRequest
*/
func (a *AuthServiceAPIService) AuthInternalDiscordLogin(ctx context.Context) ApiAuthInternalDiscordLoginRequest {
	return ApiAuthInternalDiscordLoginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthDiscordLoginResponse
func (a *AuthServiceAPIService) AuthInternalDiscordLoginExecute(r ApiAuthInternalDiscordLoginRequest) (*AuthDiscordLoginResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthDiscordLoginResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalDiscordLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/discord/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalEmailLoginRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthEmailLoginRequest
}

func (r ApiAuthInternalEmailLoginRequest) Body(body AuthEmailLoginRequest) ApiAuthInternalEmailLoginRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalEmailLoginRequest) Execute() (*AuthEmailLoginResponse, *http.Response, error) {
	return r.ApiService.AuthInternalEmailLoginExecute(r)
}

/*
AuthInternalEmailLogin Email Login

Logs in the user based on the email and OTP specified and returns a session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalEmailLoginRequest
*/
func (a *AuthServiceAPIService) AuthInternalEmailLogin(ctx context.Context) ApiAuthInternalEmailLoginRequest {
	return ApiAuthInternalEmailLoginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthEmailLoginResponse
func (a *AuthServiceAPIService) AuthInternalEmailLoginExecute(r ApiAuthInternalEmailLoginRequest) (*AuthEmailLoginResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthEmailLoginResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalEmailLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/login/email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalEmailPasswordLoginRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthEmailPasswordLoginRequest
}

func (r ApiAuthInternalEmailPasswordLoginRequest) Body(body AuthEmailPasswordLoginRequest) ApiAuthInternalEmailPasswordLoginRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalEmailPasswordLoginRequest) Execute() (*AuthEmailPasswordLoginResponse, *http.Response, error) {
	return r.ApiService.AuthInternalEmailPasswordLoginExecute(r)
}

/*
AuthInternalEmailPasswordLogin Email Password Login

Logs in the user based on the email and password specified and returns a session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalEmailPasswordLoginRequest
*/
func (a *AuthServiceAPIService) AuthInternalEmailPasswordLogin(ctx context.Context) ApiAuthInternalEmailPasswordLoginRequest {
	return ApiAuthInternalEmailPasswordLoginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthEmailPasswordLoginResponse
func (a *AuthServiceAPIService) AuthInternalEmailPasswordLoginExecute(r ApiAuthInternalEmailPasswordLoginRequest) (*AuthEmailPasswordLoginResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthEmailPasswordLoginResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalEmailPasswordLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/email-password/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalEpicLoginRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthEpicLoginRequest
}

func (r ApiAuthInternalEpicLoginRequest) Body(body AuthEpicLoginRequest) ApiAuthInternalEpicLoginRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalEpicLoginRequest) Execute() (*AuthEpicLoginResponse, *http.Response, error) {
	return r.ApiService.AuthInternalEpicLoginExecute(r)
}

/*
AuthInternalEpicLogin Epic Login

Logs in the user based on the epic credentials specified and returns a session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalEpicLoginRequest
*/
func (a *AuthServiceAPIService) AuthInternalEpicLogin(ctx context.Context) ApiAuthInternalEpicLoginRequest {
	return ApiAuthInternalEpicLoginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthEpicLoginResponse
func (a *AuthServiceAPIService) AuthInternalEpicLoginExecute(r ApiAuthInternalEpicLoginRequest) (*AuthEpicLoginResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthEpicLoginResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalEpicLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/login/epic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalFacebookLoginRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthFacebookLoginRequest
}

func (r ApiAuthInternalFacebookLoginRequest) Body(body AuthFacebookLoginRequest) ApiAuthInternalFacebookLoginRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalFacebookLoginRequest) Execute() (*AuthFacebookLoginResponse, *http.Response, error) {
	return r.ApiService.AuthInternalFacebookLoginExecute(r)
}

/*
AuthInternalFacebookLogin Facebook Login

Logs in the user based on the facebook credential token specified and returns a session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalFacebookLoginRequest
*/
func (a *AuthServiceAPIService) AuthInternalFacebookLogin(ctx context.Context) ApiAuthInternalFacebookLoginRequest {
	return ApiAuthInternalFacebookLoginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthFacebookLoginResponse
func (a *AuthServiceAPIService) AuthInternalFacebookLoginExecute(r ApiAuthInternalFacebookLoginRequest) (*AuthFacebookLoginResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthFacebookLoginResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalFacebookLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/login/facebook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalGetUserIdsByLoginIdsRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	loginIds *string
	loginType *string
	gateway *string
}

// Comma separated login IDs of the user to be retrieved
func (r ApiAuthInternalGetUserIdsByLoginIdsRequest) LoginIds(loginIds string) ApiAuthInternalGetUserIdsByLoginIdsRequest {
	r.loginIds = &loginIds
	return r
}

// Login type to search by. Values must be one of &#39;email&#39;, &#39;anon&#39;, &#39;apple&#39;, &#39;facebook&#39;, &#39;google&#39;, &#39;steam&#39;, &#39;xbox&#39;, &#39;epic&#39;
func (r ApiAuthInternalGetUserIdsByLoginIdsRequest) LoginType(loginType string) ApiAuthInternalGetUserIdsByLoginIdsRequest {
	r.loginType = &loginType
	return r
}

// Gateway
func (r ApiAuthInternalGetUserIdsByLoginIdsRequest) Gateway(gateway string) ApiAuthInternalGetUserIdsByLoginIdsRequest {
	r.gateway = &gateway
	return r
}

func (r ApiAuthInternalGetUserIdsByLoginIdsRequest) Execute() (*AuthGetUserIdsByLoginIdsResponse, *http.Response, error) {
	return r.ApiService.AuthInternalGetUserIdsByLoginIdsExecute(r)
}

/*
AuthInternalGetUserIdsByLoginIds Get User Ids

Get UserIDs by login IDs and login types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalGetUserIdsByLoginIdsRequest
*/
func (a *AuthServiceAPIService) AuthInternalGetUserIdsByLoginIds(ctx context.Context) ApiAuthInternalGetUserIdsByLoginIdsRequest {
	return ApiAuthInternalGetUserIdsByLoginIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthGetUserIdsByLoginIdsResponse
func (a *AuthServiceAPIService) AuthInternalGetUserIdsByLoginIdsExecute(r ApiAuthInternalGetUserIdsByLoginIdsRequest) (*AuthGetUserIdsByLoginIdsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthGetUserIdsByLoginIdsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalGetUserIdsByLoginIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.loginIds == nil {
		return localVarReturnValue, nil, reportError("loginIds is required and must be specified")
	}
	if r.loginType == nil {
		return localVarReturnValue, nil, reportError("loginType is required and must be specified")
	}
	if r.gateway == nil {
		return localVarReturnValue, nil, reportError("gateway is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "login_ids", r.loginIds, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "login_type", r.loginType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Gateway", r.gateway, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalGetUsernameAvailabilityRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	username *string
}

// Username to check
func (r ApiAuthInternalGetUsernameAvailabilityRequest) Username(username string) ApiAuthInternalGetUsernameAvailabilityRequest {
	r.username = &username
	return r
}

func (r ApiAuthInternalGetUsernameAvailabilityRequest) Execute() (*AuthGetUsernameAvailabilityResponse, *http.Response, error) {
	return r.ApiService.AuthInternalGetUsernameAvailabilityExecute(r)
}

/*
AuthInternalGetUsernameAvailability Username Password Login

Checks if the username is available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalGetUsernameAvailabilityRequest
*/
func (a *AuthServiceAPIService) AuthInternalGetUsernameAvailability(ctx context.Context) ApiAuthInternalGetUsernameAvailabilityRequest {
	return ApiAuthInternalGetUsernameAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthGetUsernameAvailabilityResponse
func (a *AuthServiceAPIService) AuthInternalGetUsernameAvailabilityExecute(r ApiAuthInternalGetUsernameAvailabilityRequest) (*AuthGetUsernameAvailabilityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthGetUsernameAvailabilityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalGetUsernameAvailability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/username-password/availability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.username == nil {
		return localVarReturnValue, nil, reportError("username is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalGoogleLoginRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthGoogleLoginRequest
}

func (r ApiAuthInternalGoogleLoginRequest) Body(body AuthGoogleLoginRequest) ApiAuthInternalGoogleLoginRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalGoogleLoginRequest) Execute() (*AuthGoogleLoginResponse, *http.Response, error) {
	return r.ApiService.AuthInternalGoogleLoginExecute(r)
}

/*
AuthInternalGoogleLogin Google Login

Logs in the user based on the google credential token specified and returns a session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalGoogleLoginRequest
*/
func (a *AuthServiceAPIService) AuthInternalGoogleLogin(ctx context.Context) ApiAuthInternalGoogleLoginRequest {
	return ApiAuthInternalGoogleLoginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthGoogleLoginResponse
func (a *AuthServiceAPIService) AuthInternalGoogleLoginExecute(r ApiAuthInternalGoogleLoginRequest) (*AuthGoogleLoginResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthGoogleLoginResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalGoogleLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/login/google"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalLogoutRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	token string
	gateway *string
}

// Gateway
func (r ApiAuthInternalLogoutRequest) Gateway(gateway string) ApiAuthInternalLogoutRequest {
	r.gateway = &gateway
	return r
}

func (r ApiAuthInternalLogoutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AuthInternalLogoutExecute(r)
}

/*
AuthInternalLogout Logout User

Ends the current session of the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Session token to logout
 @return ApiAuthInternalLogoutRequest
*/
func (a *AuthServiceAPIService) AuthInternalLogout(ctx context.Context, token string) ApiAuthInternalLogoutRequest {
	return ApiAuthInternalLogoutRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AuthServiceAPIService) AuthInternalLogoutExecute(r ApiAuthInternalLogoutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalLogout")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/logout/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gateway == nil {
		return localVarReturnValue, nil, reportError("gateway is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Gateway", r.gateway, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalOtpRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthOtpRequest
}

func (r ApiAuthInternalOtpRequest) Body(body AuthOtpRequest) ApiAuthInternalOtpRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalOtpRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AuthInternalOtpExecute(r)
}

/*
AuthInternalOtp Email Login

Generates an OTP and sends it to the email for logging in

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalOtpRequest
*/
func (a *AuthServiceAPIService) AuthInternalOtp(ctx context.Context) ApiAuthInternalOtpRequest {
	return ApiAuthInternalOtpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AuthServiceAPIService) AuthInternalOtpExecute(r ApiAuthInternalOtpRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalOtp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/otp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalRecoverEmailAccountRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthRecoverEmailAccountRequest
}

func (r ApiAuthInternalRecoverEmailAccountRequest) Body(body AuthRecoverEmailAccountRequest) ApiAuthInternalRecoverEmailAccountRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalRecoverEmailAccountRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AuthInternalRecoverEmailAccountExecute(r)
}

/*
AuthInternalRecoverEmailAccount Email Password Login

Sends an email to the user for account recovery

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalRecoverEmailAccountRequest
*/
func (a *AuthServiceAPIService) AuthInternalRecoverEmailAccount(ctx context.Context) ApiAuthInternalRecoverEmailAccountRequest {
	return ApiAuthInternalRecoverEmailAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AuthServiceAPIService) AuthInternalRecoverEmailAccountExecute(r ApiAuthInternalRecoverEmailAccountRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalRecoverEmailAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/email-password/account-recovery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalRefreshRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	gateway *string
	body *AuthRefreshRequest
}

// Gateway
func (r ApiAuthInternalRefreshRequest) Gateway(gateway string) ApiAuthInternalRefreshRequest {
	r.gateway = &gateway
	return r
}

func (r ApiAuthInternalRefreshRequest) Body(body AuthRefreshRequest) ApiAuthInternalRefreshRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalRefreshRequest) Execute() (*AuthRefreshResponse, *http.Response, error) {
	return r.ApiService.AuthInternalRefreshExecute(r)
}

/*
AuthInternalRefresh Token

Refreshes the session and returns a new session token with refreshed validity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalRefreshRequest
*/
func (a *AuthServiceAPIService) AuthInternalRefresh(ctx context.Context) ApiAuthInternalRefreshRequest {
	return ApiAuthInternalRefreshRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthRefreshResponse
func (a *AuthServiceAPIService) AuthInternalRefreshExecute(r ApiAuthInternalRefreshRequest) (*AuthRefreshResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthRefreshResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalRefresh")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gateway == nil {
		return localVarReturnValue, nil, reportError("gateway is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Gateway", r.gateway, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalSteamLoginRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthSteamLoginRequest
}

func (r ApiAuthInternalSteamLoginRequest) Body(body AuthSteamLoginRequest) ApiAuthInternalSteamLoginRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalSteamLoginRequest) Execute() (*AuthSteamLoginResponse, *http.Response, error) {
	return r.ApiService.AuthInternalSteamLoginExecute(r)
}

/*
AuthInternalSteamLogin Steam Login

Logs in the user based on the steam token specified and returns a session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalSteamLoginRequest

Deprecated
*/
func (a *AuthServiceAPIService) AuthInternalSteamLogin(ctx context.Context) ApiAuthInternalSteamLoginRequest {
	return ApiAuthInternalSteamLoginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthSteamLoginResponse
// Deprecated
func (a *AuthServiceAPIService) AuthInternalSteamLoginExecute(r ApiAuthInternalSteamLoginRequest) (*AuthSteamLoginResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthSteamLoginResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalSteamLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/login/steam"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalSteamOpenIdLoginRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthSteamOpenIdLoginRequest
}

func (r ApiAuthInternalSteamOpenIdLoginRequest) Body(body AuthSteamOpenIdLoginRequest) ApiAuthInternalSteamOpenIdLoginRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalSteamOpenIdLoginRequest) Execute() (*AuthSteamLoginResponse, *http.Response, error) {
	return r.ApiService.AuthInternalSteamOpenIdLoginExecute(r)
}

/*
AuthInternalSteamOpenIdLogin Steam Login

Logs in the user based on the steam open ID token specified and returns a session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalSteamOpenIdLoginRequest
*/
func (a *AuthServiceAPIService) AuthInternalSteamOpenIdLogin(ctx context.Context) ApiAuthInternalSteamOpenIdLoginRequest {
	return ApiAuthInternalSteamOpenIdLoginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthSteamLoginResponse
func (a *AuthServiceAPIService) AuthInternalSteamOpenIdLoginExecute(r ApiAuthInternalSteamOpenIdLoginRequest) (*AuthSteamLoginResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthSteamLoginResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalSteamOpenIdLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/steam/openid/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalSteamSessionTicketLoginRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthSteamSessionTicketLoginRequest
}

func (r ApiAuthInternalSteamSessionTicketLoginRequest) Body(body AuthSteamSessionTicketLoginRequest) ApiAuthInternalSteamSessionTicketLoginRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalSteamSessionTicketLoginRequest) Execute() (*AuthSteamLoginResponse, *http.Response, error) {
	return r.ApiService.AuthInternalSteamSessionTicketLoginExecute(r)
}

/*
AuthInternalSteamSessionTicketLogin Steam Login

Logs in the user based on the steam session ticket specified and returns a session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalSteamSessionTicketLoginRequest
*/
func (a *AuthServiceAPIService) AuthInternalSteamSessionTicketLogin(ctx context.Context) ApiAuthInternalSteamSessionTicketLoginRequest {
	return ApiAuthInternalSteamSessionTicketLoginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthSteamLoginResponse
func (a *AuthServiceAPIService) AuthInternalSteamSessionTicketLoginExecute(r ApiAuthInternalSteamSessionTicketLoginRequest) (*AuthSteamLoginResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthSteamLoginResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalSteamSessionTicketLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/steam/session-ticket/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalUpdateEmailPasswordRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthUpdateEmailPasswordRequest
}

func (r ApiAuthInternalUpdateEmailPasswordRequest) Body(body AuthUpdateEmailPasswordRequest) ApiAuthInternalUpdateEmailPasswordRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalUpdateEmailPasswordRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AuthInternalUpdateEmailPasswordExecute(r)
}

/*
AuthInternalUpdateEmailPassword Email Password Login

Updates the email and password of the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalUpdateEmailPasswordRequest
*/
func (a *AuthServiceAPIService) AuthInternalUpdateEmailPassword(ctx context.Context) ApiAuthInternalUpdateEmailPasswordRequest {
	return ApiAuthInternalUpdateEmailPasswordRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AuthServiceAPIService) AuthInternalUpdateEmailPasswordExecute(r ApiAuthInternalUpdateEmailPasswordRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalUpdateEmailPassword")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/email-password/password"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalUpdateUsernamePasswordRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	gateway *string
	body *AuthUpdateUsernamePasswordRequest
}

// Gateway
func (r ApiAuthInternalUpdateUsernamePasswordRequest) Gateway(gateway string) ApiAuthInternalUpdateUsernamePasswordRequest {
	r.gateway = &gateway
	return r
}

func (r ApiAuthInternalUpdateUsernamePasswordRequest) Body(body AuthUpdateUsernamePasswordRequest) ApiAuthInternalUpdateUsernamePasswordRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalUpdateUsernamePasswordRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AuthInternalUpdateUsernamePasswordExecute(r)
}

/*
AuthInternalUpdateUsernamePassword Username Password Login

Updates the username and password of the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalUpdateUsernamePasswordRequest
*/
func (a *AuthServiceAPIService) AuthInternalUpdateUsernamePassword(ctx context.Context) ApiAuthInternalUpdateUsernamePasswordRequest {
	return ApiAuthInternalUpdateUsernamePasswordRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AuthServiceAPIService) AuthInternalUpdateUsernamePasswordExecute(r ApiAuthInternalUpdateUsernamePasswordRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalUpdateUsernamePassword")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/username-password/password"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gateway == nil {
		return localVarReturnValue, nil, reportError("gateway is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Gateway", r.gateway, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalUsernamePasswordLoginRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthUsernamePasswordLoginRequest
}

func (r ApiAuthInternalUsernamePasswordLoginRequest) Body(body AuthUsernamePasswordLoginRequest) ApiAuthInternalUsernamePasswordLoginRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalUsernamePasswordLoginRequest) Execute() (*AuthUsernamePasswordLoginResponse, *http.Response, error) {
	return r.ApiService.AuthInternalUsernamePasswordLoginExecute(r)
}

/*
AuthInternalUsernamePasswordLogin Username Password Login

Logs in the user based on the username and password specified and returns a session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalUsernamePasswordLoginRequest
*/
func (a *AuthServiceAPIService) AuthInternalUsernamePasswordLogin(ctx context.Context) ApiAuthInternalUsernamePasswordLoginRequest {
	return ApiAuthInternalUsernamePasswordLoginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthUsernamePasswordLoginResponse
func (a *AuthServiceAPIService) AuthInternalUsernamePasswordLoginExecute(r ApiAuthInternalUsernamePasswordLoginRequest) (*AuthUsernamePasswordLoginResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthUsernamePasswordLoginResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalUsernamePasswordLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/username-password/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalValidateRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthValidateRequest
}

func (r ApiAuthInternalValidateRequest) Body(body AuthValidateRequest) ApiAuthInternalValidateRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalValidateRequest) Execute() (*AuthValidateResponse, *http.Response, error) {
	return r.ApiService.AuthInternalValidateExecute(r)
}

/*
AuthInternalValidate Token

Validates the session of the user and returns the user info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalValidateRequest
*/
func (a *AuthServiceAPIService) AuthInternalValidate(ctx context.Context) ApiAuthInternalValidateRequest {
	return ApiAuthInternalValidateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthValidateResponse
func (a *AuthServiceAPIService) AuthInternalValidateExecute(r ApiAuthInternalValidateRequest) (*AuthValidateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthValidateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalValidate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalVerifyEmailRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthVerifyEmailRequest
}

func (r ApiAuthInternalVerifyEmailRequest) Body(body AuthVerifyEmailRequest) ApiAuthInternalVerifyEmailRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalVerifyEmailRequest) Execute() (*AuthVerifyEmailResponse, *http.Response, error) {
	return r.ApiService.AuthInternalVerifyEmailExecute(r)
}

/*
AuthInternalVerifyEmail Email Password Login

Verifies the email and returns a session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalVerifyEmailRequest
*/
func (a *AuthServiceAPIService) AuthInternalVerifyEmail(ctx context.Context) ApiAuthInternalVerifyEmailRequest {
	return ApiAuthInternalVerifyEmailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthVerifyEmailResponse
func (a *AuthServiceAPIService) AuthInternalVerifyEmailExecute(r ApiAuthInternalVerifyEmailRequest) (*AuthVerifyEmailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthVerifyEmailResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalVerifyEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/email-password/verification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthInternalXboxLoginRequest struct {
	ctx context.Context
	ApiService *AuthServiceAPIService
	body *AuthXboxLoginRequest
}

func (r ApiAuthInternalXboxLoginRequest) Body(body AuthXboxLoginRequest) ApiAuthInternalXboxLoginRequest {
	r.body = &body
	return r
}

func (r ApiAuthInternalXboxLoginRequest) Execute() (*AuthXboxLoginResponse, *http.Response, error) {
	return r.ApiService.AuthInternalXboxLoginExecute(r)
}

/*
AuthInternalXboxLogin Xbox Login

Logs in the user based on the xbox token specified and returns a session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthInternalXboxLoginRequest
*/
func (a *AuthServiceAPIService) AuthInternalXboxLogin(ctx context.Context) ApiAuthInternalXboxLoginRequest {
	return ApiAuthInternalXboxLoginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthXboxLoginResponse
func (a *AuthServiceAPIService) AuthInternalXboxLoginExecute(r ApiAuthInternalXboxLoginRequest) (*AuthXboxLoginResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthXboxLoginResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthServiceAPIService.AuthInternalXboxLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/login/xbox"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
