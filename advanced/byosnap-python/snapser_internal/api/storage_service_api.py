# coding: utf-8

"""
    game-dev

    Your custom SDK

    The version of the OpenAPI document: game-dev: v2 SDK
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from pydantic import Field, StrictStr, conlist

from typing import Optional

from snapser_internal.models.append_arr_sub_document_request import AppendArrSubDocumentRequest
from snapser_internal.models.increment_counter_request import IncrementCounterRequest
from snapser_internal.models.insert_blob_request import InsertBlobRequest
from snapser_internal.models.insert_json_blob_request import InsertJsonBlobRequest
from snapser_internal.models.prepend_arr_sub_document_request import PrependArrSubDocumentRequest
from snapser_internal.models.replace_blob_request import ReplaceBlobRequest
from snapser_internal.models.replace_json_blob_request import ReplaceJsonBlobRequest
from snapser_internal.models.storage_append_arr_sub_document_response import StorageAppendArrSubDocumentResponse
from snapser_internal.models.storage_batch_append_arr_sub_documents_request import StorageBatchAppendArrSubDocumentsRequest
from snapser_internal.models.storage_batch_append_arr_sub_documents_response import StorageBatchAppendArrSubDocumentsResponse
from snapser_internal.models.storage_batch_delete_json_blobs_request import StorageBatchDeleteJsonBlobsRequest
from snapser_internal.models.storage_batch_delete_json_blobs_response import StorageBatchDeleteJsonBlobsResponse
from snapser_internal.models.storage_batch_delete_sub_documents_request import StorageBatchDeleteSubDocumentsRequest
from snapser_internal.models.storage_batch_delete_sub_documents_response import StorageBatchDeleteSubDocumentsResponse
from snapser_internal.models.storage_batch_get_append_blobs_response import StorageBatchGetAppendBlobsResponse
from snapser_internal.models.storage_batch_get_blobs_response import StorageBatchGetBlobsResponse
from snapser_internal.models.storage_batch_get_counters_response import StorageBatchGetCountersResponse
from snapser_internal.models.storage_batch_get_json_blobs_request import StorageBatchGetJsonBlobsRequest
from snapser_internal.models.storage_batch_get_json_blobs_response import StorageBatchGetJsonBlobsResponse
from snapser_internal.models.storage_batch_get_sub_documents_request import StorageBatchGetSubDocumentsRequest
from snapser_internal.models.storage_batch_get_sub_documents_response import StorageBatchGetSubDocumentsResponse
from snapser_internal.models.storage_batch_increment_counter_request import StorageBatchIncrementCounterRequest
from snapser_internal.models.storage_batch_increment_counter_response import StorageBatchIncrementCounterResponse
from snapser_internal.models.storage_batch_insert_blob_request import StorageBatchInsertBlobRequest
from snapser_internal.models.storage_batch_insert_blob_response import StorageBatchInsertBlobResponse
from snapser_internal.models.storage_batch_insert_json_blobs_request import StorageBatchInsertJsonBlobsRequest
from snapser_internal.models.storage_batch_insert_json_blobs_response import StorageBatchInsertJsonBlobsResponse
from snapser_internal.models.storage_batch_prepend_arr_sub_documents_request import StorageBatchPrependArrSubDocumentsRequest
from snapser_internal.models.storage_batch_prepend_arr_sub_documents_response import StorageBatchPrependArrSubDocumentsResponse
from snapser_internal.models.storage_batch_replace_blob_request import StorageBatchReplaceBlobRequest
from snapser_internal.models.storage_batch_replace_blob_response import StorageBatchReplaceBlobResponse
from snapser_internal.models.storage_batch_replace_json_blobs_request import StorageBatchReplaceJsonBlobsRequest
from snapser_internal.models.storage_batch_replace_json_blobs_response import StorageBatchReplaceJsonBlobsResponse
from snapser_internal.models.storage_batch_update_append_blob_request import StorageBatchUpdateAppendBlobRequest
from snapser_internal.models.storage_batch_update_append_blob_response import StorageBatchUpdateAppendBlobResponse
from snapser_internal.models.storage_batch_upsert_sub_documents_request import StorageBatchUpsertSubDocumentsRequest
from snapser_internal.models.storage_batch_upsert_sub_documents_response import StorageBatchUpsertSubDocumentsResponse
from snapser_internal.models.storage_delete_append_blob_response import StorageDeleteAppendBlobResponse
from snapser_internal.models.storage_delete_blob_response import StorageDeleteBlobResponse
from snapser_internal.models.storage_delete_json_blob_response import StorageDeleteJsonBlobResponse
from snapser_internal.models.storage_delete_sub_document_response import StorageDeleteSubDocumentResponse
from snapser_internal.models.storage_get_append_blob_response import StorageGetAppendBlobResponse
from snapser_internal.models.storage_get_blob_response import StorageGetBlobResponse
from snapser_internal.models.storage_get_cas_response import StorageGetCasResponse
from snapser_internal.models.storage_get_counter_response import StorageGetCounterResponse
from snapser_internal.models.storage_get_json_blob_response import StorageGetJsonBlobResponse
from snapser_internal.models.storage_get_sub_document_response import StorageGetSubDocumentResponse
from snapser_internal.models.storage_increment_counter_response import StorageIncrementCounterResponse
from snapser_internal.models.storage_insert_blob_response import StorageInsertBlobResponse
from snapser_internal.models.storage_insert_json_blob_response import StorageInsertJsonBlobResponse
from snapser_internal.models.storage_prepend_arr_sub_document_response import StoragePrependArrSubDocumentResponse
from snapser_internal.models.storage_replace_blob_response import StorageReplaceBlobResponse
from snapser_internal.models.storage_replace_json_blob_response import StorageReplaceJsonBlobResponse
from snapser_internal.models.storage_reset_counter_response import StorageResetCounterResponse
from snapser_internal.models.storage_update_append_blob_response import StorageUpdateAppendBlobResponse
from snapser_internal.models.storage_upsert_sub_document_response import StorageUpsertSubDocumentResponse
from snapser_internal.models.update_append_blob_request import UpdateAppendBlobRequest
from snapser_internal.models.upsert_sub_document_request import UpsertSubDocumentRequest

from snapser_internal.api_client import ApiClient
from snapser_internal.api_response import ApiResponse
from snapser_internal.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class StorageServiceApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def storage_append_arr_sub_document(self, owner_id : Annotated[StrictStr, Field(..., description="Counter owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : AppendArrSubDocumentRequest, **kwargs) -> StorageAppendArrSubDocumentResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Append to an array sub-document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_append_arr_sub_document(owner_id, access_type, json_blob_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Counter owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: AppendArrSubDocumentRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageAppendArrSubDocumentResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_append_arr_sub_document_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_append_arr_sub_document_with_http_info(owner_id, access_type, json_blob_key, gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_append_arr_sub_document_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Counter owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : AppendArrSubDocumentRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Append to an array sub-document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_append_arr_sub_document_with_http_info(owner_id, access_type, json_blob_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Counter owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: AppendArrSubDocumentRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageAppendArrSubDocumentResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'json_blob_key',
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_append_arr_sub_document" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['json_blob_key']:
            _path_params['json_blob_key'] = _params['json_blob_key']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageAppendArrSubDocumentResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents:append', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_batch_append_arr_sub_documents(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchAppendArrSubDocumentsRequest, **kwargs) -> StorageBatchAppendArrSubDocumentsResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Append to multiple array sub-documents  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_append_arr_sub_documents(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchAppendArrSubDocumentsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageBatchAppendArrSubDocumentsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_batch_append_arr_sub_documents_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_batch_append_arr_sub_documents_with_http_info(gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_batch_append_arr_sub_documents_with_http_info(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchAppendArrSubDocumentsRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Append to multiple array sub-documents  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_append_arr_sub_documents_with_http_info(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchAppendArrSubDocumentsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageBatchAppendArrSubDocumentsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_batch_append_arr_sub_documents" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageBatchAppendArrSubDocumentsResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/batch/json-blobs/sub-documents:append', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_batch_delete_json_blobs(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchDeleteJsonBlobsRequest, **kwargs) -> StorageBatchDeleteJsonBlobsResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Deletes multiple JSON blobs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_delete_json_blobs(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchDeleteJsonBlobsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageBatchDeleteJsonBlobsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_batch_delete_json_blobs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_batch_delete_json_blobs_with_http_info(gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_batch_delete_json_blobs_with_http_info(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchDeleteJsonBlobsRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Deletes multiple JSON blobs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_delete_json_blobs_with_http_info(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchDeleteJsonBlobsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageBatchDeleteJsonBlobsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_batch_delete_json_blobs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageBatchDeleteJsonBlobsResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/batch/json-blobs:delete', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_batch_delete_sub_documents(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchDeleteSubDocumentsRequest, **kwargs) -> StorageBatchDeleteSubDocumentsResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Deletes multiple sub-documents  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_delete_sub_documents(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchDeleteSubDocumentsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageBatchDeleteSubDocumentsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_batch_delete_sub_documents_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_batch_delete_sub_documents_with_http_info(gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_batch_delete_sub_documents_with_http_info(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchDeleteSubDocumentsRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Deletes multiple sub-documents  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_delete_sub_documents_with_http_info(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchDeleteSubDocumentsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageBatchDeleteSubDocumentsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_batch_delete_sub_documents" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageBatchDeleteSubDocumentsResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/batch/json-blobs/sub-documents:delete', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_batch_get_append_blobs(self, access_type : Annotated[StrictStr, Field(..., description="Access to the append-blob. (public/protected/private)")], owner_id : Annotated[conlist(StrictStr), Field(..., description="Append-blob owners user IDs")], append_blob_key : Annotated[StrictStr, Field(..., description="Append-blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> StorageBatchGetAppendBlobsResponse:  # noqa: E501
        """Append Blobs  # noqa: E501

        Retrieve all append blobs for the owners  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_get_append_blobs(access_type, owner_id, append_blob_key, gateway, async_req=True)
        >>> result = thread.get()

        :param access_type: Access to the append-blob. (public/protected/private) (required)
        :type access_type: str
        :param owner_id: Append-blob owners user IDs (required)
        :type owner_id: List[str]
        :param append_blob_key: Append-blob key (required)
        :type append_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageBatchGetAppendBlobsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_batch_get_append_blobs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_batch_get_append_blobs_with_http_info(access_type, owner_id, append_blob_key, gateway, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_batch_get_append_blobs_with_http_info(self, access_type : Annotated[StrictStr, Field(..., description="Access to the append-blob. (public/protected/private)")], owner_id : Annotated[conlist(StrictStr), Field(..., description="Append-blob owners user IDs")], append_blob_key : Annotated[StrictStr, Field(..., description="Append-blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> ApiResponse:  # noqa: E501
        """Append Blobs  # noqa: E501

        Retrieve all append blobs for the owners  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_get_append_blobs_with_http_info(access_type, owner_id, append_blob_key, gateway, async_req=True)
        >>> result = thread.get()

        :param access_type: Access to the append-blob. (public/protected/private) (required)
        :type access_type: str
        :param owner_id: Append-blob owners user IDs (required)
        :type owner_id: List[str]
        :param append_blob_key: Append-blob key (required)
        :type append_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageBatchGetAppendBlobsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'access_type',
            'owner_id',
            'append_blob_key',
            'gateway'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_batch_get_append_blobs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('access_type') is not None:  # noqa: E501
            _query_params.append(('access_type', _params['access_type']))

        if _params.get('owner_id') is not None:  # noqa: E501
            _query_params.append(('owner_id', _params['owner_id']))
            _collection_formats['owner_id'] = 'multi'

        if _params.get('append_blob_key') is not None:  # noqa: E501
            _query_params.append(('append_blob_key', _params['append_blob_key']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageBatchGetAppendBlobsResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/batch/append-blobs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_batch_get_blobs(self, access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], owner_id : Annotated[conlist(StrictStr), Field(..., description="Blob owners user IDs")], blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> StorageBatchGetBlobsResponse:  # noqa: E501
        """Blobs  # noqa: E501

        Retrieve all blobs for the owners  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_get_blobs(access_type, owner_id, blob_key, gateway, async_req=True)
        >>> result = thread.get()

        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param owner_id: Blob owners user IDs (required)
        :type owner_id: List[str]
        :param blob_key: Blob key (required)
        :type blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageBatchGetBlobsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_batch_get_blobs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_batch_get_blobs_with_http_info(access_type, owner_id, blob_key, gateway, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_batch_get_blobs_with_http_info(self, access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], owner_id : Annotated[conlist(StrictStr), Field(..., description="Blob owners user IDs")], blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> ApiResponse:  # noqa: E501
        """Blobs  # noqa: E501

        Retrieve all blobs for the owners  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_get_blobs_with_http_info(access_type, owner_id, blob_key, gateway, async_req=True)
        >>> result = thread.get()

        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param owner_id: Blob owners user IDs (required)
        :type owner_id: List[str]
        :param blob_key: Blob key (required)
        :type blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageBatchGetBlobsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'access_type',
            'owner_id',
            'blob_key',
            'gateway'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_batch_get_blobs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('access_type') is not None:  # noqa: E501
            _query_params.append(('access_type', _params['access_type']))

        if _params.get('owner_id') is not None:  # noqa: E501
            _query_params.append(('owner_id', _params['owner_id']))
            _collection_formats['owner_id'] = 'multi'

        if _params.get('blob_key') is not None:  # noqa: E501
            _query_params.append(('blob_key', _params['blob_key']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageBatchGetBlobsResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/batch/blobs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_batch_get_counters(self, access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], owner_id : Annotated[conlist(StrictStr), Field(..., description="Counter owners user IDs")], counter_key : Annotated[StrictStr, Field(..., description="Counter key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> StorageBatchGetCountersResponse:  # noqa: E501
        """Counters  # noqa: E501

        Retrieve all counters for the owners  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_get_counters(access_type, owner_id, counter_key, gateway, async_req=True)
        >>> result = thread.get()

        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param owner_id: Counter owners user IDs (required)
        :type owner_id: List[str]
        :param counter_key: Counter key (required)
        :type counter_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageBatchGetCountersResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_batch_get_counters_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_batch_get_counters_with_http_info(access_type, owner_id, counter_key, gateway, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_batch_get_counters_with_http_info(self, access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], owner_id : Annotated[conlist(StrictStr), Field(..., description="Counter owners user IDs")], counter_key : Annotated[StrictStr, Field(..., description="Counter key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> ApiResponse:  # noqa: E501
        """Counters  # noqa: E501

        Retrieve all counters for the owners  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_get_counters_with_http_info(access_type, owner_id, counter_key, gateway, async_req=True)
        >>> result = thread.get()

        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param owner_id: Counter owners user IDs (required)
        :type owner_id: List[str]
        :param counter_key: Counter key (required)
        :type counter_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageBatchGetCountersResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'access_type',
            'owner_id',
            'counter_key',
            'gateway'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_batch_get_counters" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('access_type') is not None:  # noqa: E501
            _query_params.append(('access_type', _params['access_type']))

        if _params.get('owner_id') is not None:  # noqa: E501
            _query_params.append(('owner_id', _params['owner_id']))
            _collection_formats['owner_id'] = 'multi'

        if _params.get('counter_key') is not None:  # noqa: E501
            _query_params.append(('counter_key', _params['counter_key']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageBatchGetCountersResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/batch/counters', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_batch_get_json_blobs(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchGetJsonBlobsRequest, **kwargs) -> StorageBatchGetJsonBlobsResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Retrieve all JSON blobs for the owners  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_get_json_blobs(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchGetJsonBlobsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageBatchGetJsonBlobsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_batch_get_json_blobs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_batch_get_json_blobs_with_http_info(gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_batch_get_json_blobs_with_http_info(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchGetJsonBlobsRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Retrieve all JSON blobs for the owners  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_get_json_blobs_with_http_info(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchGetJsonBlobsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageBatchGetJsonBlobsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_batch_get_json_blobs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageBatchGetJsonBlobsResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/batch/json-blobs', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_batch_get_sub_documents(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchGetSubDocumentsRequest, **kwargs) -> StorageBatchGetSubDocumentsResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Retrieve all sub-documents for the owners  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_get_sub_documents(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchGetSubDocumentsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageBatchGetSubDocumentsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_batch_get_sub_documents_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_batch_get_sub_documents_with_http_info(gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_batch_get_sub_documents_with_http_info(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchGetSubDocumentsRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Retrieve all sub-documents for the owners  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_get_sub_documents_with_http_info(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchGetSubDocumentsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageBatchGetSubDocumentsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_batch_get_sub_documents" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageBatchGetSubDocumentsResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/batch/json-blobs/sub-documents', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_batch_increment_counter(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchIncrementCounterRequest, **kwargs) -> StorageBatchIncrementCounterResponse:  # noqa: E501
        """Counters  # noqa: E501

        Increment multiple counters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_increment_counter(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchIncrementCounterRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageBatchIncrementCounterResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_batch_increment_counter_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_batch_increment_counter_with_http_info(gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_batch_increment_counter_with_http_info(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchIncrementCounterRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """Counters  # noqa: E501

        Increment multiple counters  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_increment_counter_with_http_info(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchIncrementCounterRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageBatchIncrementCounterResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_batch_increment_counter" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageBatchIncrementCounterResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/batch/counters', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_batch_insert_blob(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchInsertBlobRequest, **kwargs) -> StorageBatchInsertBlobResponse:  # noqa: E501
        """Blobs  # noqa: E501

        Inserts multiple blobs. Will fail if the key already exists  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_insert_blob(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchInsertBlobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageBatchInsertBlobResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_batch_insert_blob_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_batch_insert_blob_with_http_info(gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_batch_insert_blob_with_http_info(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchInsertBlobRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """Blobs  # noqa: E501

        Inserts multiple blobs. Will fail if the key already exists  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_insert_blob_with_http_info(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchInsertBlobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageBatchInsertBlobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_batch_insert_blob" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageBatchInsertBlobResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/batch/blobs', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_batch_insert_json_blobs(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchInsertJsonBlobsRequest, **kwargs) -> StorageBatchInsertJsonBlobsResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Inserts multiple JSON blobs. Will fail if the key already exists  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_insert_json_blobs(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchInsertJsonBlobsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageBatchInsertJsonBlobsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_batch_insert_json_blobs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_batch_insert_json_blobs_with_http_info(gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_batch_insert_json_blobs_with_http_info(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchInsertJsonBlobsRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Inserts multiple JSON blobs. Will fail if the key already exists  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_insert_json_blobs_with_http_info(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchInsertJsonBlobsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageBatchInsertJsonBlobsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_batch_insert_json_blobs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageBatchInsertJsonBlobsResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/batch/json-blobs:insert', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_batch_prepend_arr_sub_documents(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchPrependArrSubDocumentsRequest, **kwargs) -> StorageBatchPrependArrSubDocumentsResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Prepend to multiple array sub-documents  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_prepend_arr_sub_documents(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchPrependArrSubDocumentsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageBatchPrependArrSubDocumentsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_batch_prepend_arr_sub_documents_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_batch_prepend_arr_sub_documents_with_http_info(gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_batch_prepend_arr_sub_documents_with_http_info(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchPrependArrSubDocumentsRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Prepend to multiple array sub-documents  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_prepend_arr_sub_documents_with_http_info(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchPrependArrSubDocumentsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageBatchPrependArrSubDocumentsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_batch_prepend_arr_sub_documents" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageBatchPrependArrSubDocumentsResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/batch/json-blobs/sub-documents:prepend', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_batch_replace_blob(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchReplaceBlobRequest, **kwargs) -> StorageBatchReplaceBlobResponse:  # noqa: E501
        """Blobs  # noqa: E501

        Replace multiple blobs. Optionally insert if it doesn't exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_replace_blob(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchReplaceBlobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageBatchReplaceBlobResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_batch_replace_blob_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_batch_replace_blob_with_http_info(gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_batch_replace_blob_with_http_info(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchReplaceBlobRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """Blobs  # noqa: E501

        Replace multiple blobs. Optionally insert if it doesn't exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_replace_blob_with_http_info(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchReplaceBlobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageBatchReplaceBlobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_batch_replace_blob" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageBatchReplaceBlobResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/batch/blobs', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_batch_replace_json_blobs(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchReplaceJsonBlobsRequest, **kwargs) -> StorageBatchReplaceJsonBlobsResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Replace multiple JSON blobs. Optionally insert if it doesn't exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_replace_json_blobs(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchReplaceJsonBlobsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageBatchReplaceJsonBlobsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_batch_replace_json_blobs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_batch_replace_json_blobs_with_http_info(gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_batch_replace_json_blobs_with_http_info(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchReplaceJsonBlobsRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Replace multiple JSON blobs. Optionally insert if it doesn't exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_replace_json_blobs_with_http_info(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchReplaceJsonBlobsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageBatchReplaceJsonBlobsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_batch_replace_json_blobs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageBatchReplaceJsonBlobsResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/batch/json-blobs:replace', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_batch_update_append_blob(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchUpdateAppendBlobRequest, **kwargs) -> StorageBatchUpdateAppendBlobResponse:  # noqa: E501
        """Append Blobs  # noqa: E501

        Apend to the existing blobs. Create a new one if it doesn't exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_update_append_blob(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchUpdateAppendBlobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageBatchUpdateAppendBlobResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_batch_update_append_blob_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_batch_update_append_blob_with_http_info(gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_batch_update_append_blob_with_http_info(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchUpdateAppendBlobRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """Append Blobs  # noqa: E501

        Apend to the existing blobs. Create a new one if it doesn't exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_update_append_blob_with_http_info(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchUpdateAppendBlobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageBatchUpdateAppendBlobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_batch_update_append_blob" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageBatchUpdateAppendBlobResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/batch/append-blobs', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_batch_upsert_sub_documents(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchUpsertSubDocumentsRequest, **kwargs) -> StorageBatchUpsertSubDocumentsResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Upsert multiple sub-documents. Optionally insert if it doesn't exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_upsert_sub_documents(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchUpsertSubDocumentsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageBatchUpsertSubDocumentsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_batch_upsert_sub_documents_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_batch_upsert_sub_documents_with_http_info(gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_batch_upsert_sub_documents_with_http_info(self, gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : StorageBatchUpsertSubDocumentsRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Upsert multiple sub-documents. Optionally insert if it doesn't exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_batch_upsert_sub_documents_with_http_info(gateway, body, async_req=True)
        >>> result = thread.get()

        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: StorageBatchUpsertSubDocumentsRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageBatchUpsertSubDocumentsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_batch_upsert_sub_documents" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageBatchUpsertSubDocumentsResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/batch/json-blobs/sub-documents', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_delete_append_blob(self, owner_id : Annotated[StrictStr, Field(..., description="Append-blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the append-blob. (public/protected/private)")], append_blob_key : Annotated[StrictStr, Field(..., description="Append-blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], cas : Annotated[Optional[StrictStr], Field(description="Optional CAS value retrieved from the last operation. CAS mismatch will be ignored if not passed")] = None, **kwargs) -> StorageDeleteAppendBlobResponse:  # noqa: E501
        """Append Blobs  # noqa: E501

        Deletes the append blob  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_delete_append_blob(owner_id, access_type, append_blob_key, gateway, cas, async_req=True)
        >>> result = thread.get()

        :param owner_id: Append-blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the append-blob. (public/protected/private) (required)
        :type access_type: str
        :param append_blob_key: Append-blob key (required)
        :type append_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param cas: Optional CAS value retrieved from the last operation. CAS mismatch will be ignored if not passed
        :type cas: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageDeleteAppendBlobResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_delete_append_blob_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_delete_append_blob_with_http_info(owner_id, access_type, append_blob_key, gateway, cas, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_delete_append_blob_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Append-blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the append-blob. (public/protected/private)")], append_blob_key : Annotated[StrictStr, Field(..., description="Append-blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], cas : Annotated[Optional[StrictStr], Field(description="Optional CAS value retrieved from the last operation. CAS mismatch will be ignored if not passed")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Append Blobs  # noqa: E501

        Deletes the append blob  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_delete_append_blob_with_http_info(owner_id, access_type, append_blob_key, gateway, cas, async_req=True)
        >>> result = thread.get()

        :param owner_id: Append-blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the append-blob. (public/protected/private) (required)
        :type access_type: str
        :param append_blob_key: Append-blob key (required)
        :type append_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param cas: Optional CAS value retrieved from the last operation. CAS mismatch will be ignored if not passed
        :type cas: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageDeleteAppendBlobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'append_blob_key',
            'gateway',
            'cas'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_delete_append_blob" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['append_blob_key']:
            _path_params['append_blob_key'] = _params['append_blob_key']


        # process the query parameters
        _query_params = []
        if _params.get('cas') is not None:  # noqa: E501
            _query_params.append(('cas', _params['cas']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageDeleteAppendBlobResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/append-blobs/{append_blob_key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_delete_blob(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], cas : Annotated[Optional[StrictStr], Field(description="Optional CAS value retrieved from the last operation. CAS mismatch will be ignored if not passed")] = None, **kwargs) -> StorageDeleteBlobResponse:  # noqa: E501
        """Blobs  # noqa: E501

        Delete a blob  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_delete_blob(owner_id, access_type, blob_key, gateway, cas, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param blob_key: Blob key (required)
        :type blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param cas: Optional CAS value retrieved from the last operation. CAS mismatch will be ignored if not passed
        :type cas: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageDeleteBlobResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_delete_blob_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_delete_blob_with_http_info(owner_id, access_type, blob_key, gateway, cas, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_delete_blob_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], cas : Annotated[Optional[StrictStr], Field(description="Optional CAS value retrieved from the last operation. CAS mismatch will be ignored if not passed")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Blobs  # noqa: E501

        Delete a blob  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_delete_blob_with_http_info(owner_id, access_type, blob_key, gateway, cas, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param blob_key: Blob key (required)
        :type blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param cas: Optional CAS value retrieved from the last operation. CAS mismatch will be ignored if not passed
        :type cas: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageDeleteBlobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'blob_key',
            'gateway',
            'cas'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_delete_blob" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['blob_key']:
            _path_params['blob_key'] = _params['blob_key']


        # process the query parameters
        _query_params = []
        if _params.get('cas') is not None:  # noqa: E501
            _query_params.append(('cas', _params['cas']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageDeleteBlobResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/blobs/{blob_key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_delete_json_blob(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], cas : Annotated[Optional[StrictStr], Field(description="Optional CAS value retrieved from the last operation. CAS mismatch will be ignored if not passed")] = None, **kwargs) -> StorageDeleteJsonBlobResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Deletes the JSON blob  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_delete_json_blob(owner_id, access_type, json_blob_key, gateway, cas, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param cas: Optional CAS value retrieved from the last operation. CAS mismatch will be ignored if not passed
        :type cas: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageDeleteJsonBlobResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_delete_json_blob_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_delete_json_blob_with_http_info(owner_id, access_type, json_blob_key, gateway, cas, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_delete_json_blob_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], cas : Annotated[Optional[StrictStr], Field(description="Optional CAS value retrieved from the last operation. CAS mismatch will be ignored if not passed")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Deletes the JSON blob  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_delete_json_blob_with_http_info(owner_id, access_type, json_blob_key, gateway, cas, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param cas: Optional CAS value retrieved from the last operation. CAS mismatch will be ignored if not passed
        :type cas: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageDeleteJsonBlobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'json_blob_key',
            'gateway',
            'cas'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_delete_json_blob" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['json_blob_key']:
            _path_params['json_blob_key'] = _params['json_blob_key']


        # process the query parameters
        _query_params = []
        if _params.get('cas') is not None:  # noqa: E501
            _query_params.append(('cas', _params['cas']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageDeleteJsonBlobResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_delete_sub_document(self, owner_id : Annotated[StrictStr, Field(..., description="Counter owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], path : Annotated[StrictStr, Field(..., description="Path to the sub-document")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], cas : Annotated[Optional[StrictStr], Field(description="Optional CAS value retrieved from the last operation. CAS mismatch will be ignored if not passed")] = None, **kwargs) -> StorageDeleteSubDocumentResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Deletes the sub-document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_delete_sub_document(owner_id, access_type, json_blob_key, path, gateway, cas, async_req=True)
        >>> result = thread.get()

        :param owner_id: Counter owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param path: Path to the sub-document (required)
        :type path: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param cas: Optional CAS value retrieved from the last operation. CAS mismatch will be ignored if not passed
        :type cas: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageDeleteSubDocumentResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_delete_sub_document_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_delete_sub_document_with_http_info(owner_id, access_type, json_blob_key, path, gateway, cas, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_delete_sub_document_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Counter owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], path : Annotated[StrictStr, Field(..., description="Path to the sub-document")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], cas : Annotated[Optional[StrictStr], Field(description="Optional CAS value retrieved from the last operation. CAS mismatch will be ignored if not passed")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Deletes the sub-document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_delete_sub_document_with_http_info(owner_id, access_type, json_blob_key, path, gateway, cas, async_req=True)
        >>> result = thread.get()

        :param owner_id: Counter owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param path: Path to the sub-document (required)
        :type path: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param cas: Optional CAS value retrieved from the last operation. CAS mismatch will be ignored if not passed
        :type cas: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageDeleteSubDocumentResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'json_blob_key',
            'path',
            'gateway',
            'cas'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_delete_sub_document" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['json_blob_key']:
            _path_params['json_blob_key'] = _params['json_blob_key']

        if _params['path']:
            _path_params['path'] = _params['path']


        # process the query parameters
        _query_params = []
        if _params.get('cas') is not None:  # noqa: E501
            _query_params.append(('cas', _params['cas']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageDeleteSubDocumentResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents/{path}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_get_append_blob(self, owner_id : Annotated[StrictStr, Field(..., description="Append-blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the append-blob. (public/protected/private)")], append_blob_key : Annotated[StrictStr, Field(..., description="Append-blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> StorageGetAppendBlobResponse:  # noqa: E501
        """Append Blobs  # noqa: E501

        Retrieve the value of an append blob  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_get_append_blob(owner_id, access_type, append_blob_key, gateway, async_req=True)
        >>> result = thread.get()

        :param owner_id: Append-blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the append-blob. (public/protected/private) (required)
        :type access_type: str
        :param append_blob_key: Append-blob key (required)
        :type append_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageGetAppendBlobResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_get_append_blob_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_get_append_blob_with_http_info(owner_id, access_type, append_blob_key, gateway, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_get_append_blob_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Append-blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the append-blob. (public/protected/private)")], append_blob_key : Annotated[StrictStr, Field(..., description="Append-blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> ApiResponse:  # noqa: E501
        """Append Blobs  # noqa: E501

        Retrieve the value of an append blob  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_get_append_blob_with_http_info(owner_id, access_type, append_blob_key, gateway, async_req=True)
        >>> result = thread.get()

        :param owner_id: Append-blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the append-blob. (public/protected/private) (required)
        :type access_type: str
        :param append_blob_key: Append-blob key (required)
        :type append_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageGetAppendBlobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'append_blob_key',
            'gateway'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_get_append_blob" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['append_blob_key']:
            _path_params['append_blob_key'] = _params['append_blob_key']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageGetAppendBlobResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/append-blobs/{append_blob_key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_get_blob(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> StorageGetBlobResponse:  # noqa: E501
        """Blobs  # noqa: E501

        Retrieve the blob for the key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_get_blob(owner_id, access_type, blob_key, gateway, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param blob_key: Blob key (required)
        :type blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageGetBlobResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_get_blob_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_get_blob_with_http_info(owner_id, access_type, blob_key, gateway, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_get_blob_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> ApiResponse:  # noqa: E501
        """Blobs  # noqa: E501

        Retrieve the blob for the key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_get_blob_with_http_info(owner_id, access_type, blob_key, gateway, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param blob_key: Blob key (required)
        :type blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageGetBlobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'blob_key',
            'gateway'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_get_blob" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['blob_key']:
            _path_params['blob_key'] = _params['blob_key']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageGetBlobResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/blobs/{blob_key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_get_cas(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> StorageGetCasResponse:  # noqa: E501
        """Cas  # noqa: E501

        Retrieve the cas for the key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_get_cas(owner_id, access_type, blob_key, gateway, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param blob_key: Blob key (required)
        :type blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageGetCasResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_get_cas_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_get_cas_with_http_info(owner_id, access_type, blob_key, gateway, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_get_cas_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> ApiResponse:  # noqa: E501
        """Cas  # noqa: E501

        Retrieve the cas for the key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_get_cas_with_http_info(owner_id, access_type, blob_key, gateway, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param blob_key: Blob key (required)
        :type blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageGetCasResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'blob_key',
            'gateway'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_get_cas" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['blob_key']:
            _path_params['blob_key'] = _params['blob_key']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageGetCasResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/cas/{blob_key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_get_counter(self, owner_id : Annotated[StrictStr, Field(..., description="Counter owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], counter_key : Annotated[StrictStr, Field(..., description="Counter key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> StorageGetCounterResponse:  # noqa: E501
        """Counters  # noqa: E501

        Retrieve a counter value  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_get_counter(owner_id, access_type, counter_key, gateway, async_req=True)
        >>> result = thread.get()

        :param owner_id: Counter owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param counter_key: Counter key (required)
        :type counter_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageGetCounterResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_get_counter_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_get_counter_with_http_info(owner_id, access_type, counter_key, gateway, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_get_counter_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Counter owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], counter_key : Annotated[StrictStr, Field(..., description="Counter key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> ApiResponse:  # noqa: E501
        """Counters  # noqa: E501

        Retrieve a counter value  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_get_counter_with_http_info(owner_id, access_type, counter_key, gateway, async_req=True)
        >>> result = thread.get()

        :param owner_id: Counter owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param counter_key: Counter key (required)
        :type counter_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageGetCounterResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'counter_key',
            'gateway'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_get_counter" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['counter_key']:
            _path_params['counter_key'] = _params['counter_key']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageGetCounterResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/counters/{counter_key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_get_json_blob(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> StorageGetJsonBlobResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Retrieve the JSON blob for the key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_get_json_blob(owner_id, access_type, json_blob_key, gateway, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageGetJsonBlobResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_get_json_blob_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_get_json_blob_with_http_info(owner_id, access_type, json_blob_key, gateway, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_get_json_blob_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Retrieve the JSON blob for the key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_get_json_blob_with_http_info(owner_id, access_type, json_blob_key, gateway, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageGetJsonBlobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'json_blob_key',
            'gateway'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_get_json_blob" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['json_blob_key']:
            _path_params['json_blob_key'] = _params['json_blob_key']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageGetJsonBlobResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_get_sub_document(self, owner_id : Annotated[StrictStr, Field(..., description="Counter owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], path : Annotated[StrictStr, Field(..., description="Path to the sub-document")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> StorageGetSubDocumentResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Retrieve the sub-document for the key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_get_sub_document(owner_id, access_type, json_blob_key, path, gateway, async_req=True)
        >>> result = thread.get()

        :param owner_id: Counter owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param path: Path to the sub-document (required)
        :type path: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageGetSubDocumentResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_get_sub_document_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_get_sub_document_with_http_info(owner_id, access_type, json_blob_key, path, gateway, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_get_sub_document_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Counter owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], path : Annotated[StrictStr, Field(..., description="Path to the sub-document")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Retrieve the sub-document for the key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_get_sub_document_with_http_info(owner_id, access_type, json_blob_key, path, gateway, async_req=True)
        >>> result = thread.get()

        :param owner_id: Counter owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param path: Path to the sub-document (required)
        :type path: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageGetSubDocumentResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'json_blob_key',
            'path',
            'gateway'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_get_sub_document" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['json_blob_key']:
            _path_params['json_blob_key'] = _params['json_blob_key']

        if _params['path']:
            _path_params['path'] = _params['path']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageGetSubDocumentResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents/{path}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_increment_counter(self, owner_id : Annotated[StrictStr, Field(..., description="Counter owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], counter_key : Annotated[StrictStr, Field(..., description="Counter key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : IncrementCounterRequest, **kwargs) -> StorageIncrementCounterResponse:  # noqa: E501
        """Counters  # noqa: E501

        Increment the counter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_increment_counter(owner_id, access_type, counter_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Counter owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param counter_key: Counter key (required)
        :type counter_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: IncrementCounterRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageIncrementCounterResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_increment_counter_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_increment_counter_with_http_info(owner_id, access_type, counter_key, gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_increment_counter_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Counter owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], counter_key : Annotated[StrictStr, Field(..., description="Counter key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : IncrementCounterRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """Counters  # noqa: E501

        Increment the counter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_increment_counter_with_http_info(owner_id, access_type, counter_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Counter owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param counter_key: Counter key (required)
        :type counter_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: IncrementCounterRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageIncrementCounterResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'counter_key',
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_increment_counter" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['counter_key']:
            _path_params['counter_key'] = _params['counter_key']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageIncrementCounterResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/counters/{counter_key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_insert_blob(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : InsertBlobRequest, **kwargs) -> StorageInsertBlobResponse:  # noqa: E501
        """Blobs  # noqa: E501

        Inserts a blob. Will fail if the key already exists  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_insert_blob(owner_id, access_type, blob_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param blob_key: Blob key (required)
        :type blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: InsertBlobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageInsertBlobResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_insert_blob_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_insert_blob_with_http_info(owner_id, access_type, blob_key, gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_insert_blob_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : InsertBlobRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """Blobs  # noqa: E501

        Inserts a blob. Will fail if the key already exists  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_insert_blob_with_http_info(owner_id, access_type, blob_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param blob_key: Blob key (required)
        :type blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: InsertBlobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageInsertBlobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'blob_key',
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_insert_blob" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['blob_key']:
            _path_params['blob_key'] = _params['blob_key']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageInsertBlobResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/blobs/{blob_key}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_insert_json_blob(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : InsertJsonBlobRequest, **kwargs) -> StorageInsertJsonBlobResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Inserts a JSON blob. Will fail if the key already exists  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_insert_json_blob(owner_id, access_type, json_blob_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: InsertJsonBlobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageInsertJsonBlobResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_insert_json_blob_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_insert_json_blob_with_http_info(owner_id, access_type, json_blob_key, gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_insert_json_blob_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : InsertJsonBlobRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Inserts a JSON blob. Will fail if the key already exists  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_insert_json_blob_with_http_info(owner_id, access_type, json_blob_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: InsertJsonBlobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageInsertJsonBlobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'json_blob_key',
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_insert_json_blob" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['json_blob_key']:
            _path_params['json_blob_key'] = _params['json_blob_key']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageInsertJsonBlobResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_prepend_arr_sub_document(self, owner_id : Annotated[StrictStr, Field(..., description="Counter owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : PrependArrSubDocumentRequest, **kwargs) -> StoragePrependArrSubDocumentResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Prepend to an array sub-document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_prepend_arr_sub_document(owner_id, access_type, json_blob_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Counter owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: PrependArrSubDocumentRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StoragePrependArrSubDocumentResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_prepend_arr_sub_document_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_prepend_arr_sub_document_with_http_info(owner_id, access_type, json_blob_key, gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_prepend_arr_sub_document_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Counter owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : PrependArrSubDocumentRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Prepend to an array sub-document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_prepend_arr_sub_document_with_http_info(owner_id, access_type, json_blob_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Counter owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: PrependArrSubDocumentRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StoragePrependArrSubDocumentResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'json_blob_key',
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_prepend_arr_sub_document" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['json_blob_key']:
            _path_params['json_blob_key'] = _params['json_blob_key']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StoragePrependArrSubDocumentResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents:prepend', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_replace_blob(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : ReplaceBlobRequest, **kwargs) -> StorageReplaceBlobResponse:  # noqa: E501
        """Blobs  # noqa: E501

        Replace a blob. Optionally insert if it doesn't exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_replace_blob(owner_id, access_type, blob_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param blob_key: Blob key (required)
        :type blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: ReplaceBlobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageReplaceBlobResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_replace_blob_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_replace_blob_with_http_info(owner_id, access_type, blob_key, gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_replace_blob_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : ReplaceBlobRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """Blobs  # noqa: E501

        Replace a blob. Optionally insert if it doesn't exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_replace_blob_with_http_info(owner_id, access_type, blob_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param blob_key: Blob key (required)
        :type blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: ReplaceBlobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageReplaceBlobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'blob_key',
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_replace_blob" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['blob_key']:
            _path_params['blob_key'] = _params['blob_key']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageReplaceBlobResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/blobs/{blob_key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_replace_json_blob(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : ReplaceJsonBlobRequest, **kwargs) -> StorageReplaceJsonBlobResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Replace a JSON blob. Optionally insert if it doesn't exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_replace_json_blob(owner_id, access_type, json_blob_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: ReplaceJsonBlobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageReplaceJsonBlobResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_replace_json_blob_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_replace_json_blob_with_http_info(owner_id, access_type, json_blob_key, gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_replace_json_blob_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the blob. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : ReplaceJsonBlobRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Replace a JSON blob. Optionally insert if it doesn't exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_replace_json_blob_with_http_info(owner_id, access_type, json_blob_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the blob. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: ReplaceJsonBlobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageReplaceJsonBlobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'json_blob_key',
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_replace_json_blob" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['json_blob_key']:
            _path_params['json_blob_key'] = _params['json_blob_key']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageReplaceJsonBlobResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_reset_counter(self, owner_id : Annotated[StrictStr, Field(..., description="Counter owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], counter_key : Annotated[StrictStr, Field(..., description="Counter key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> StorageResetCounterResponse:  # noqa: E501
        """Counters  # noqa: E501

        Reset a counter value to 0  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_reset_counter(owner_id, access_type, counter_key, gateway, async_req=True)
        >>> result = thread.get()

        :param owner_id: Counter owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param counter_key: Counter key (required)
        :type counter_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageResetCounterResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_reset_counter_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_reset_counter_with_http_info(owner_id, access_type, counter_key, gateway, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_reset_counter_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Counter owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], counter_key : Annotated[StrictStr, Field(..., description="Counter key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], **kwargs) -> ApiResponse:  # noqa: E501
        """Counters  # noqa: E501

        Reset a counter value to 0  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_reset_counter_with_http_info(owner_id, access_type, counter_key, gateway, async_req=True)
        >>> result = thread.get()

        :param owner_id: Counter owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param counter_key: Counter key (required)
        :type counter_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageResetCounterResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'counter_key',
            'gateway'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_reset_counter" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['counter_key']:
            _path_params['counter_key'] = _params['counter_key']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageResetCounterResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/counters/{counter_key}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_update_append_blob(self, owner_id : Annotated[StrictStr, Field(..., description="Append-blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the append-blob. (public/protected/private)")], append_blob_key : Annotated[StrictStr, Field(..., description="Append-blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : UpdateAppendBlobRequest, **kwargs) -> StorageUpdateAppendBlobResponse:  # noqa: E501
        """Append Blobs  # noqa: E501

        Apend to the existing blob. Create a new one if it doesn't exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_update_append_blob(owner_id, access_type, append_blob_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Append-blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the append-blob. (public/protected/private) (required)
        :type access_type: str
        :param append_blob_key: Append-blob key (required)
        :type append_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: UpdateAppendBlobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageUpdateAppendBlobResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_update_append_blob_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_update_append_blob_with_http_info(owner_id, access_type, append_blob_key, gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_update_append_blob_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Append-blob owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the append-blob. (public/protected/private)")], append_blob_key : Annotated[StrictStr, Field(..., description="Append-blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : UpdateAppendBlobRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """Append Blobs  # noqa: E501

        Apend to the existing blob. Create a new one if it doesn't exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_update_append_blob_with_http_info(owner_id, access_type, append_blob_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Append-blob owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the append-blob. (public/protected/private) (required)
        :type access_type: str
        :param append_blob_key: Append-blob key (required)
        :type append_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: UpdateAppendBlobRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageUpdateAppendBlobResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'append_blob_key',
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_update_append_blob" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['append_blob_key']:
            _path_params['append_blob_key'] = _params['append_blob_key']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageUpdateAppendBlobResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/append-blobs/{append_blob_key}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def storage_upsert_sub_document(self, owner_id : Annotated[StrictStr, Field(..., description="Counter owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : UpsertSubDocumentRequest, **kwargs) -> StorageUpsertSubDocumentResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Upsert a sub-document. Optionally insert if it doesn't exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_upsert_sub_document(owner_id, access_type, json_blob_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Counter owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: UpsertSubDocumentRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageUpsertSubDocumentResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the storage_upsert_sub_document_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.storage_upsert_sub_document_with_http_info(owner_id, access_type, json_blob_key, gateway, body, **kwargs)  # noqa: E501

    @validate_arguments
    def storage_upsert_sub_document_with_http_info(self, owner_id : Annotated[StrictStr, Field(..., description="Counter owner's user ID")], access_type : Annotated[StrictStr, Field(..., description="Access to the counter. (public/protected/private)")], json_blob_key : Annotated[StrictStr, Field(..., description="Blob key")], gateway : Annotated[StrictStr, Field(..., description="Gateway")], body : UpsertSubDocumentRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """JSON Blobs  # noqa: E501

        Upsert a sub-document. Optionally insert if it doesn't exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_upsert_sub_document_with_http_info(owner_id, access_type, json_blob_key, gateway, body, async_req=True)
        >>> result = thread.get()

        :param owner_id: Counter owner's user ID (required)
        :type owner_id: str
        :param access_type: Access to the counter. (public/protected/private) (required)
        :type access_type: str
        :param json_blob_key: Blob key (required)
        :type json_blob_key: str
        :param gateway: Gateway (required)
        :type gateway: str
        :param body: (required)
        :type body: UpsertSubDocumentRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageUpsertSubDocumentResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'owner_id',
            'access_type',
            'json_blob_key',
            'gateway',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_upsert_sub_document" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['owner_id']:
            _path_params['owner_id'] = _params['owner_id']

        if _params['access_type']:
            _path_params['access_type'] = _params['access_type']

        if _params['json_blob_key']:
            _path_params['json_blob_key'] = _params['json_blob_key']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['gateway']:
            _header_params['Gateway'] = _params['gateway']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StorageUpsertSubDocumentResponse",
        }

        return self.api_client.call_api(
            '/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
